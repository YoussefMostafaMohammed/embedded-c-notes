
# **Practical-Patterns**

### **Table of Contents**
1. **[Lookup Tables in Practice](#1-lookup-tables-in-practice)**
2. **[Bootloader Vector Tables](#2-bootloader-vector-tables)**
3. **[Memory Overflow Detection](#3-memory-overflow-detection)**
4. **[PID Controller Failure Modes](#4-pid-controller-failure-modes)**

---

### **1. Lookup Tables in Practice**

**Sine wave for motor PWM:**
```c
const uint16_t sine_lookup[360] = {
    0, 17, 35, 52, 70, 87, 105, 122, 140, 157, 175, 192,
    // ... (generated by Python: int(sin(i*PI/180)*65535))
};

void set_motor_angle(uint16_t angle) {
    uint16_t pwm = sine_lookup[angle % 360] >> 2;  // Scale to 14-bit
    TIM2->CCR1 = pwm;  // Update PWM duty cycle
}
```

**Why 150x faster:**
- **sinf()**: 300 cycles (floating-point, polynomial approximation)
- **Lookup**: 2 cycles (memory read)
- **In PID loop**: Difference between 20kHz and 100Hz update rate

**Memory dump:**
```
08001200:  0000 1100 2300 3500 4700 5a00 6d00 7f00
08001210:  9100 a400 b700 ca00 dd00 f000 0301 1701
```

---

### **2. Bootloader Vector Tables**

**Bootloader (0x08000000)**
```c
// Vector table at start of Flash
__attribute__((section(".isr_vector")))
void (* const bootloader_vectors[46])(void) = {
    (void*)0x20010000,    // Initial SP (bootloader stack)
    bootloader_main,      // Reset (stays in bootloader)
    NMI_Handler,          // NMI
    HardFault_Handler,
    // ...
};

void bootloader_main(void) {
    if(button_pressed) {
        // Stay in bootloader
        run_bootloader_cli();
    } else {
        jump_to_app(0x08008000);
    }
}
```

**Application (0x08008000)**
```c
// Must have its own vector table
__attribute__((section(".app_vector")))
void (* const app_vectors[46])(void) = {
    (void*)0x20018000,    // App's own stack
    app_main,             // App's Reset_Handler
    app_nmi_handler,      // App's NMI
    // ...
};

void jump_to_app(uint32_t app_addr) {
    // Disable interrupts
    __disable_irq();
    
    // Remap vector table
    SCB->VTOR = app_addr;  // Now ISR addresses come from app
    
    // Set new stack pointer
    uint32_t sp = *(uint32_t*)app_addr;
    __set_MSP(sp);
    
    // Jump to app
    uint32_t reset_handler = *(uint32_t*)(app_addr + 4);
    ((void(*)())reset_handler)();
}
```

**Why VTOR matters:**
- After jump, if USART1 interrupt fires, CPU reads vector from **new table**
- If VTOR not changed, ISR would jump to bootloader's handler (wrong code)

---

### **3. Memory Overflow Detection**

**Magic number placement:**
```c
#define STACK_GUARD 0xDEADBEEF

void SystemInit(void) {
    // Place guard at stack-heap gap
    *(uint32_t*)0x2000EFFC = STACK_GUARD;
    
    // Enable MemManage fault
    SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
}

// Call periodically or on fault
void check_overflow(void) {
    if(*(uint32_t*)0x2000EFFC != STACK_GUARD) {
        // Stack overflowed, corrupted heap
        NVIC_SystemReset();  // Reboot
    }
}
```

**MemManage fault handler:**
```c
void MemManage_Handler(void) {
    // Cortex-M can detect stack overflow automatically
    if(SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
        // Stack error during exception
        // SP moved beyond limit
        while(1);  // Halt
    }
}
```

**What happens on overflow:**
```
Before: [0x2000EFFC] = DEADBEEF
Stack grows down into gap...
After:  [0x2000EFFC] = 12345678 (corrupted)
check_overflow() detects change → reboot
```

---

### **4. PID Controller Failure Modes**

**The quadcopter problem:**
```c
void pid_update(void) {
    // Must run every 1ms (1000Hz)
    error = setpoint - actual;
    integral += error;
    derivative = error - last_error;
    
    output = Kp*error + Ki*integral + Kd*derivative;
    
    // Set motor PWM
    TIM1->CCR1 = output;
}
```

**Failure mode 1: Non-deterministic timing**
```c
void pid_update(void) {
    float *tmp = malloc(100);  // BAD!
    // malloc takes 5μs sometimes, 5ms other times
    // PID loop now runs at 200Hz, not 1000Hz
    // Drone becomes unstable
}
```

**Failure mode 2: Stack overflow**
```c
void pid_update(void) {
    float matrix[100][100];  // 40KB on stack!
    // Stack overflow → corrupts globals
    // Integral term becomes NAN → motor spins to max
}
```

**Failure mode 3: Missing volatile**
```c
int sensor_value;  // Not volatile

void pid_update(void) {
    // Compiler optimizes to read once
    while(sensor_value < threshold) {
        // Waits forever if sensor_value changes
    }
}
```

**Correct implementation:**
```c
static float integral;           // .data, persistent
static float last_error;         // .data, persistent

void pid_update(void) {
    volatile int sensor = read_sensor();  // volatile!
    
    // Fixed-point math (no floats)
    int32_t error = setpoint - sensor;
    integral += error;
    
    // Saturate integral (prevent windup)
    if(integral > 1000) integral = 1000;
    if(integral < -1000) integral = -1000;
    
    int32_t output = (Kp * error + Ki * integral) >> 16;
    
    TIM1->CCR1 = output;  // Update PWM
}
```

**All failure modes share root cause:** Violation of **determinism**, **resource limits**, or **hardware access rules**.

---

## **Final Word: The Embedded Mindset**

Every decision in Embedded C is a **tradeoff**:

| Goal | **Cost** | **Consequence of Wrong Choice** |
|------|----------|----------------------------------|
| Save Flash | Use more RAM | RAM exhaustion → need bigger MCU |
| Save RAM | Use more Flash | Code bloat → slower boot, less feature room |
| Speed up | Use more power | Battery dies faster |
| Safety | Reduce performance | Miss real-time deadlines → physical failure |

**The best embedded engineers:**
1. **Measure everything:** Flash size, RAM usage, cycle counts
2. **Understand hardware:** Know what each instruction costs
3. **Think deterministically:** "Will this ALWAYS complete in time?"
4. **Respect resource limits:** RAM is not infinite, CPU is not infinitely fast
5. **Ask "why" for every line:** Every byte has a cost
